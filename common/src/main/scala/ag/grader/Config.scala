package ag.grader

import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.{ExecutorService, Executors}
import upickle.default.*

import java.nio.file.NoSuchFileException
import java.security.MessageDigest
import scala.concurrent.ExecutionContext
import java.util.Properties
import java.time.OffsetDateTime
import scala.reflect.ClassTag

/** Defines the parameters the should/could be supplied externally
  */
trait Config {

  def counter: AtomicLong
  def criticalCount: AtomicLong
  val threadId: ThreadLocal[Long]

  /** number of threads to use
    */
  val threads: Int

  /** base directory for all files and directories used during the run
    */
  def baseDir: os.Path

  /** direcotry for the dropbox; the place where students copy their public keys
    * permissions should be sticky and world-writable but not world-readable
    */
  def dropBox: os.Path

  /** direcotry in which html reports are generated
    */
  def htmlDir: os.Path

  /** directory in which prepared repos are created
    */
  def preparedDir: os.Path

  /** directory in which repos are cloned/updated
    */
  def reposDir: os.Path

  /** directory in which scratch directories are created (e.g. to run a
    * submission)
    */
  def scratchDir: os.Path

  /** directory in which stdout/stderr files are redirected
    */
  def stdOutErr: os.Path

  /** the trace file, containing all text generated by calling "trace" including
    * a record of all executed external commands
    */
  def traceFile: os.Path

  /** base directory for where working directories should go
    */
  def workDir: os.Path

  /** git user id (for access to gitolite)
    */
  def gitUser: String

  /** gitolite host
    */
  def gitHost: String

  /** gitolite port
    */
  def gitPort: Int

  /** group id to map to inside docker
    */
  def groupId: String

  /** user id to map to inside docker
    */
  def userId: String

  /** domain name to which reports are sent @<reportDomain>
    */
  def reportDomain: String

  /** user id to which copies of all reports are sent
    * <reportDefaultUser>@<reportDomin>
    */
  def reportDefaultUser: String
}

/** A config with some reasonable defaults
  */
case class SimpleConfig(
    gitHost: String,
    gitUser: String,
    gitPort: Int,
    threads: Int,
    optBaseDir: Option[os.Path] = None,
    reportDomain: String,
    reportDefaultUser: String
) extends Config
    derives ReadWriter {
  val baseDir: os.Path = optBaseDir match {
    case Some(p) => p
    case _       => os.pwd
  }
  val workDir: os.Path = baseDir / "work"
  val traceFile: os.Path = baseDir / "trace"
  val gitLogDateFormat: String = "--date=format-local:%Y:%m:%d:%H:%M:%S"
  val dropBox: os.Path = os.home / "dropbox"
  val htmlDir: os.Path = os.home / "public_html"

  val userId: String = os.proc("id", "-u").call().out.lines().head
  val groupId: String = os.proc("id", "-g").call().out.lines().head

  // check critical failures from previous runs //
  {
    val criticalFiles = os.list(os.pwd).filter(_.last.endsWith(".critical"))
    if (criticalFiles.nonEmpty) {
      println(criticalFiles)
      throw new Exception(
        "critical files exists, handle the problem then run again. Just deleting the files is not a good idea"
      )
    }
  }

  val preparedDir: os.Path = baseDir / "prepared"

  val reposDir: os.Path = workDir / "repos"
  os.makeDir.all(reposDir)
  val stdOutErr: os.Path = workDir / "std"
  os.makeDir.all(stdOutErr)
  val scratchDir: os.Path = workDir / "scratch"
  os.makeDir.all(scratchDir)
  // val gitServer: SshServer = SshServer(gitUser, gitHost, gitPort)

  val counter: AtomicLong = new AtomicLong(0)

  val criticalCount: AtomicLong = new AtomicLong(0)

  private val threadIds = new AtomicLong(0)

  val threadId: ThreadLocal[Long] = new ThreadLocal[Long] {
    override def initialValue(): Long = threadIds.getAndIncrement()
  }

  os.remove.all(traceFile)
  os.write(traceFile, "")

  os.remove.all(stdOutErr)
  os.makeDir.all(stdOutErr)

  os.remove.all(scratchDir)
  os.makeDir.all(scratchDir)
}

object SimpleConfig {

  /** load a SimpleConfig from the defailt place
    */
  def load: SimpleConfig =
    read[SimpleConfig]((os.pwd / "config.json").toNIO)

}

object Config {
  def get()(using world: World): Config = world.get[Config] {
    SimpleConfig.load
  }
}
